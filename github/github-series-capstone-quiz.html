<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Mastery Quiz (75 Questions)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --bg: #f4f7f9;
            --surface: #ffffff;
            --surface-soft: #eef2f5;
            --text: #1a202c;
            --muted: #4a5568;
            --line: #e2e8f0;
            --header-bg: #2d3748;
            --header-text: #f7fafc;
            --accent: #dd6b20;
            --accent-deep: #c05621;
            --correct: #38a169;
            --correct-soft: #f0fff4;
            --wrong: #e53e3e;
            --wrong-soft: #fff5f5;
            --font-main: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }
        body {
            font-family: var(--font-main);
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .app {
            width: 100%;
            max-width: 900px;
            margin: 2rem auto;
            background: var(--surface);
            border-radius: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex;
            flex-direction: column;
        }
        .app__header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 1rem 1.5rem;
            border-bottom: 4px solid var(--accent);
        }
        .progress__bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 9999px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        .progress__fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            border-radius: 9999px;
            transition: width 0.3s ease;
        }
        .main {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
        }
        .card {
            background: var(--surface);
        }
        .q-head {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .q-index {
            font-weight: 700;
            color: var(--accent);
            font-size: 1rem;
        }
        .q-labels {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .q-category {
            font-size: 0.75rem;
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            background: var(--surface-soft);
            border: 1px solid var(--line);
            color: var(--muted);
            font-weight: 600;
            text-transform: capitalize;
        }
        .q-text {
            margin: 0.5rem 0 1.5rem;
            line-height: 1.6;
            font-weight: 500;
            font-size: 1.125rem;
        }
        .option {
            display: flex;
            align-items: center;
            border: 2px solid var(--line);
            border-radius: 0.75rem;
            padding: 0.8rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #fff;
            margin-bottom: 0.75rem;
        }
        .option:hover {
            border-color: var(--accent);
            background-color: #fffaf0;
        }
        .option.is-selected {
            border-color: var(--accent);
            background-color: #fffaf0;
            box-shadow: 0 0 0 3px rgba(221, 107, 32, 0.2);
        }
        .option.is-correct {
            border-color: var(--correct);
            background-color: var(--correct-soft);
            color: var(--correct);
            font-weight: 600;
        }
        .option.is-wrong {
            border-color: var(--wrong);
            background-color: var(--wrong-soft);
            color: var(--wrong);
            font-weight: 600;
        }
        .option[disabled] {
            opacity: 0.8;
            cursor: not-allowed;
        }
        .feedback {
            margin-top: 1.5rem;
            border-left-width: 4px;
            padding: 1rem;
            border-radius: 0.5rem;
            line-height: 1.6;
            display: none;
        }
        .feedback.is-correct {
            border-color: var(--correct);
            background-color: var(--correct-soft);
        }
        .feedback.is-wrong {
            border-color: var(--wrong);
            background-color: var(--wrong-soft);
        }
        .feedback-title {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        .feedback-explanation p:first-child {
            margin-top: 0.5rem;
        }
        .feedback-pro-tip {
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.6);
            border-radius: 0.5rem;
            font-size: 0.9rem;
        }
        .ftb-input {
            width: 100%;
            padding: 0.8rem 1rem;
            border: 2px solid var(--line);
            border-radius: 0.75rem;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .ftb-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(221, 107, 32, 0.2);
        }
        .seq-list, .match-container { margin-top: 1rem; }
        .seq-item {
            border: 2px solid var(--line);
            border-radius: 0.75rem;
            background-color: #fff;
            padding: 0.8rem 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            cursor: grab;
            user-select: none;
            margin-bottom: 0.5rem;
        }
        .seq-item .handle { opacity: 0.5; }
        .seq-item.dragging { opacity: 0.5; background-color: #fffaf0; border-color: var(--accent); }
        .match-grid { display: grid; gap: 1rem; grid-template-columns: 1fr; }
        @media(min-width: 640px) { .match-grid { grid-template-columns: 1fr 1fr; } }
        .m-item {
            border: 2px solid var(--line);
            border-radius: 0.75rem;
            background-color: #fff;
            padding: 0.8rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .m-item:hover { background-color: #fffaf0; }
        .m-item.is-picked {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(221, 107, 32, 0.2);
        }
        .m-item[disabled] { cursor: not-allowed; }
        .rtc-context {
            border-left: 4px solid var(--accent);
            background: var(--surface-soft);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            line-height: 1.6;
            color: var(--muted);
        }
        .rtc-sub-question {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--line);
        }
        .nav {
            border-top: 1px solid var(--line);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--surface-soft);
        }
        .btn {
            border: none;
            border-radius: 0.5rem;
            padding: 0.6rem 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
        }
        .btn--pri {
            background-color: var(--accent);
            color: #fff;
        }
        .btn--pri:hover:not(:disabled) {
            background-color: var(--accent-deep);
        }
        .btn--sec {
            background-color: #fff;
            color: var(--muted);
            border: 1px solid var(--line);
        }
        .btn--sec:hover:not(:disabled) {
            background-color: var(--surface-soft);
            border-color: var(--muted);
        }
        .btn--skip {
            background-color: #a0aec0;
            color: #fff;
            border: 1px solid #718096;
        }
        .btn--skip:hover:not(:disabled) {
            background-color: #718096;
        }
        .btn[disabled] {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .final-score-card { text-align: center; padding: 2rem; }
        .final-score { font-size: 3rem; font-weight: 800; color: var(--accent); }
    </style>
</head>
<body>

<div class="app" id="app">
    <header class="app__header">
        <div class="flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold">GitHub Mastery Assessment</h1>
                <p class="text-sm opacity-80">A comprehensive 75-question quiz on Git & GitHub workflows.</p>
            </div>
            <div id="meta-info" class="text-right">
                <span id="badgeIndex" class="font-semibold">Q 1 / 75</span>
            </div>
        </div>
        <div class="progress__bar">
            <div class="progress__fill" id="progressBar"></div>
        </div>
    </header>

    <main class="main">
        <div class="card" id="qCard">
            <!-- Question content will be dynamically rendered here -->
        </div>
    </main>

    <footer class="nav">
        <button class="btn btn--sec" id="btnPrev">‚Üê Previous</button>
        <div class="flex items-center gap-2">
            <button class="btn btn--skip" id="btnSkip">Skip</button>
            <button class="btn btn--pri" id="btnSubmit">Submit Answer</button>
            <button class="btn btn--pri hidden" id="btnNext">Next ‚Üí</button>
        </div>
    </footer>
</div>

<script>
const QUIZ_DATA = {
    title: "GitHub Mastery Quiz",
    totalQuestions: 75,
    questions: [
        // SECTION 1: Git & GitHub Fundamentals (15 Qs)
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is the fundamental difference between Git and GitHub?",
            options: [
                "They are the same thing.",
                "Git is a company; GitHub is their main product.",
                "Git is the version control tool; GitHub is a web platform for hosting Git repositories.",
                "GitHub is an older, outdated version of Git."
            ],
            correct: 2,
            explain: {
                correct: "This is the perfect distinction. Git is the software that runs on your computer to track changes, while GitHub is a service that hosts your repositories online and provides collaboration tools.",
                incorrect: "This is a common point of confusion. Git is the underlying technology, and you can use it without ever using GitHub. GitHub, however, relies on Git to function.",
                proTip: "Think of it like email: the email protocol (like SMTP) is Git, and a service like Gmail is GitHub. You need the protocol to send mail, but you use a service to manage it easily."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is the primary role of the 'staging area' (or index) in Git?",
            options: [
                "To permanently store a backup of your files.",
                "To preview how your code will look on the website.",
                "To carefully craft which changes will be included in the next commit.",
                "To share files with teammates before committing them."
            ],
            correct: 2,
            explain: {
                correct: "Exactly. The staging area acts as a 'drafting table' where you can add, remove, and review changes before finalizing them into a commit.",
                incorrect: "The staging area is a temporary holding place, not a permanent storage or sharing mechanism. It's all about preparing your next snapshot.",
                proTip: "Professional developers use the staging area to create small, logical commits. Instead of committing 10 unrelated changes at once, they stage and commit them one by one for a clean, understandable history."
            }
        },
        {
            type: "FTB",
            difficulty: "Easy",
            section: 1,
            text: "The command to download a repository from GitHub to your computer for the very first time is `git ______`.",
            answer: "clone",
            explain: {
                correct: "`clone` is the correct command. It creates a full local copy of the remote repository, including its entire history.",
                incorrect: "While `pull` or `fetch` also download data, `clone` is used specifically for creating the initial local copy of a remote repository.",
                proTip: "When you run `git clone`, Git automatically sets up a remote named 'origin' that points back to the URL you cloned from, making it easy to push and pull later."
            }
        },
        {
            type: "TF",
            difficulty: "Easy",
            section: 1,
            text: "A 'commit' in Git stores only the specific lines that have changed since the previous commit.",
            correct: false,
            explain: {
                correct: "Correct, this statement is false. This is a common misconception. A commit stores a complete snapshot of all tracked files at a point in time by referencing a 'tree' object.",
                incorrect: "While Git is very efficient at storing changes, the fundamental unit is a snapshot, not a 'diff' or 'patch'. This snapshot model is what makes Git so powerful and fast.",
                proTip: "Because Git stores snapshots, checking out a previous version is incredibly fast‚Äîit just has to load that specific snapshot, not recalculate history by applying thousands of tiny changes."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "Which command is used to upload your local commits to the remote repository on GitHub?",
            options: ["git commit", "git upload", "git push", "git send"],
            correct: 2,
            explain: {
                correct: "`git push` is the correct command. It takes your committed changes from your local repository and uploads them to the remote one.",
                incorrect: "`git commit` only saves changes to your *local* repository. You must explicitly `push` to share them.",
                proTip: "A common workflow is to make several commits locally and then `push` them all at once when your work is complete or at a good stopping point."
            }
        },
        {
            type: "Sequence",
            difficulty: "Easy",
            section: 1,
            text: "Arrange the core actions of the local Git workflow into the correct order.",
            items: ["git push", "Make changes to a file", "git commit", "git add"],
            correct: ["Make changes to a file", "git add", "git commit", "git push"],
            explain: {
                correct: "This is the fundamental cycle of a Git developer: You edit your files, stage them with `add`, save the snapshot locally with `commit`, and then share it with the remote using `push`.",
                incorrect: "The order is crucial. You cannot commit something that hasn't been staged, and you cannot push a commit that hasn't been made.",
                proTip: "Get comfortable with this `edit -> add -> commit -> push` cycle. It's the most common sequence of commands you will ever use with Git."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What does the `.git` directory in your project folder contain?",
            options: [
                "Only the most recent version of your files.",
                "A backup of your project's images and videos.",
                "The entire history and metadata of your repository.",
                "Configuration files for GitHub's website."
            ],
            correct: 2,
            explain: {
                correct: "Correct. The `.git` directory is the repository itself. It's a database containing all your commits, branches, tags, and other objects that make up your project's history.",
                incorrect: "This directory contains the *entire* history, not just the recent version. It's the engine of your local repository.",
                proTip: "Never manually edit files inside the `.git` directory unless you are an expert! A wrong change can corrupt your entire repository."
            }
        },
        {
            type: "FTB",
            difficulty: "Easy",
            section: 1,
            text: "To get the latest updates from the remote repository to your local machine, you should run the command `git ____`.",
            answer: "pull",
            explain: {
                correct: "`pull` is the correct command. It fetches changes from the remote repository and immediately tries to merge them into your current branch.",
                incorrect: "While `push` sends changes up, `pull` brings them down. They are the two primary commands for syncing with a remote.",
                proTip: "It's a best practice to `git pull` before you start working each day to ensure you have the latest code from your team."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "When you run `git add file.txt`, what are you doing?",
            options: [
                "Adding the file to your GitHub repository.",
                "Adding the file's current state to the staging area.",
                "Adding a new user to the project.",
                "Saving the file permanently."
            ],
            correct: 1,
            explain: {
                correct: "Exactly. `git add` takes a snapshot of the file at that moment and places it in the staging area, preparing it for the next commit.",
                incorrect: "The file is not sent to GitHub or saved permanently until you run `git commit` (to save locally) and `git push` (to send to GitHub).",
                proTip: "If you `git add` a file and then change it again, the new changes are *not* staged. You must run `git add` again to update the snapshot in the staging area."
            }
        },
        {
            type: "TF",
            difficulty: "Easy",
            section: 1,
            text: "A 'local' repository is the copy of the project hosted on GitHub's servers.",
            correct: false,
            explain: {
                correct: "Correct, this statement is false. A 'local' repository is the one on your own computer. The copy on GitHub's servers is called the 'remote' repository.",
                incorrect: "The distinction between local and remote is fundamental to Git's distributed nature.",
                proTip: "Because you have a full 'local' copy of the history, you can do most of your work (like committing and viewing logs) completely offline."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is the purpose of the `-m` flag in the command `git commit -m 'Initial commit'`?",
            options: [
                "To merge the commit with another branch.",
                "To move the file to a new directory.",
                "To specify the commit message directly on the command line.",
                "To mark the commit as a minor change."
            ],
            correct: 2,
            explain: {
                correct: "Correct. The `-m` flag stands for 'message' and allows you to provide the commit message without opening a text editor.",
                incorrect: "Without the `-m` flag, Git will open your configured text editor (like Vim or VS Code) for you to write a longer commit message.",
                proTip: "Use `-m` for short, simple messages. For more complex changes that need explanation, omit `-m` to open an editor where you can write a subject line and a detailed body."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "If you've made changes to a file but haven't staged or committed them, what command will show you the status of your working directory?",
            options: ["git log", "git show", "git diff", "git status"],
            correct: 3,
            explain: {
                correct: "`git status` is your go-to command for seeing what's happening in your repository. It shows untracked files, modified files, and staged changes.",
                incorrect: "`git diff` shows the actual line-by-line changes, but `git status` gives you the high-level overview of which files have been changed.",
                proTip: "Run `git status` frequently. It's the best way to keep track of your work and avoid committing the wrong files."
            }
        },
         {
            type: "TF",
            difficulty: "Easy",
            section: 1,
            text: "Once a commit is made, it can be easily edited or deleted from the project's history.",
            correct: false,
            explain: {
                correct: "Correct, this statement is false. Git's history is largely immutable, meaning unchangeable. You don't edit old commits; you create new ones that reverse or change previous work.",
                incorrect: "This immutability is a core security and integrity feature of Git. It ensures that the history of a project is a reliable record.",
                proTip: "While advanced commands like `git rebase` can *appear* to edit history, they actually create new commits and discard the old ones. This is a crucial distinction."
            }
        },
        {
            type: "FTB",
            difficulty: "Easy",
            section: 1,
            text: "The unique 40-character identifier for a commit, tree, or blob is called a ______ hash.",
            answer: "SHA",
            explain: {
                correct: "SHA (or SHA-1) is the correct term. It stands for Secure Hash Algorithm, and it's how Git ensures that every object in its database has a unique ID.",
                incorrect: "This hash is generated based on the content of the object, so any tiny change to a file will result in a completely different SHA for its corresponding blob and subsequent commits.",
                proTip: "You don't need to use the full 40 characters. Git can usually identify an object by the first 7-10 characters of its SHA hash."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is a `README.md` file?",
            options: [
                "A file that contains secret code.",
                "A configuration file for Git.",
                "A file, written in Markdown, that provides information about the project.",
                "A log of all the errors in the project."
            ],
            correct: 2,
            explain: {
                correct: "Correct. The `README.md` is the front page of your repository. It should explain what the project is, how to install it, and how to use it.",
                incorrect: "The `.md` extension stands for Markdown, a simple way to format text with headings, lists, links, and images.",
                proTip: "A high-quality `README.md` is the most important part of a good project. It's the first thing a new user or contributor will see."
            }
        },
        // SECTION 2: Team Collaboration Workflows (18 Qs)
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "In a team environment, what is the primary purpose of creating a 'branch'?",
            options: [
                "To create a permanent backup of the main project.",
                "To delete files without affecting the main project.",
                "To work on a new feature or bug fix in isolation without disrupting the main codebase.",
                "To give a teammate a copy of your code."
            ],
            correct: 2,
            explain: {
                correct: "This is the core reason for branching. It creates a safe, isolated environment where you can develop and test new ideas without destabilizing the main, shared branch.",
                incorrect: "Branches are designed to be temporary and merged back into the main project, not for permanent backups or file deletion.",
                proTip: "A common and effective strategy is to create a new branch for every single task, no matter how small. This is often called 'feature branching'."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "What is a 'Pull Request' (PR) on GitHub?",
            options: [
                "A command to download the latest code from the repository.",
                "A formal request to have your branch's changes reviewed and then merged into another branch.",
                "A demand to remove another person's code from the project.",
                "A notification that the project has a bug."
            ],
            correct: 1,
            explain: {
                correct: "Correct. A PR is the central mechanism for collaboration on GitHub. It's where code review, discussion, and automated checks happen before changes are integrated.",
                incorrect: "The term comes from the idea that you are requesting the project maintainer to `pull` your changes into their repository.",
                proTip: "A great PR has a clear title, a detailed description explaining the 'what' and 'why' of the change, and a link to any relevant issue."
            }
        },
        {
            type: "RTC",
            difficulty: "Medium",
            section: 2,
            title: "RTC 1: The Solo Founder's First Hire",
            context: "Alex has been building a web application alone and committing directly to the `main` branch. Alex just hired Ben, their first developer. Alex needs to set up the repository so Ben can start working on a new feature, a 'Contact Us' page, without interfering with the live code on `main`.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the FIRST thing Alex should do on GitHub to give Ben access to the repository?",
                    options: [
                        "Email Ben the code in a zip file.",
                        "Add Ben as a 'collaborator' in the repository settings.",
                        "Tell Ben to 'fork' the repository.",
                        "Create a 'ben-branch' for him."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. Adding Ben as a collaborator gives him push access, allowing him to push branches directly to the main repository, which is standard for a small, trusted team.",
                        incorrect: "Forking is for external contributors. As a core team member, Ben should be a collaborator.",
                        proTip: "In repository settings under 'Collaborators and teams', you can grant different permission levels (Read, Triage, Write, Maintain, Admin)."
                    }
                },
                {
                    type: "MCQ",
                    text: "What is the best practice Ben should follow to start working on the 'Contact Us' page?",
                    options: [
                        "Start coding directly on the `main` branch.",
                        "Clone the repository, and then create a new branch called `feature/contact-page`.",
                        "Ask Alex to make the changes for him.",
                        "Wait for Alex to create the branch."
                    ],
                    correct: 1,
                    explain: {
                        correct: "This is the ideal workflow. Ben should create a descriptive, short-lived branch for his specific task to keep his work isolated from `main`.",
                        incorrect: "Working directly on `main` is a bad practice that can lead to instability and conflicts. Each new piece of work should get its own branch.",
                        proTip: "A common branch naming convention is `type/short-description`, e.g., `feature/user-login` or `bugfix/typo-in-header`."
                    }
                },
                {
                    type: "FTB",
                    text: "Once Ben finishes his work on the new branch, he will push it to GitHub and open a ________ ________ to get his code reviewed by Alex.",
                    answer: "Pull Request",
                    explain: {
                        correct: "A Pull Request (PR) is the correct term. It's the mechanism Ben will use to propose his changes and ask Alex for a review before merging.",
                        incorrect: "This step is crucial for quality control and knowledge sharing, even on a small team.",
                        proTip: "When opening the PR, Ben should assign Alex as a reviewer to ensure Alex gets a notification."
                    }
                }
            ]
        },
        {
            type: "TF",
            difficulty: "Easy",
            section: 2,
            text: "A 'merge conflict' occurs when two developers create a branch with the exact same name.",
            correct: false,
            explain: {
                correct: "Correct, this is false. A merge conflict occurs when two branches have competing changes to the *same lines* in the *same file*. Branch names have nothing to do with it.",
                incorrect: "While having identically named branches from two different people could be confusing, it wouldn't cause a technical merge conflict in Git.",
                proTip: "The best way to avoid merge conflicts is frequent communication and regularly pulling the latest changes from the `main` branch into your feature branch."
            }
        },
         {
            type: "MATCH",
            difficulty: "Medium",
            section: 2,
            text: "Match the GitHub term to its primary function in a collaborative workflow.",
            stems: ["Branch", "Pull Request", "Merge", "Fork"],
            responses: [
                "A personal, server-side copy of a repository, used for contributing to a project you don't have write access to.",
                "The action of integrating the changes from one branch into another.",
                "A proposal to integrate changes, serving as a venue for code review and discussion.",
                "An independent line of development used to isolate work."
            ],
            correct: [{ s: 0, r: 3 }, { s: 1, r: 2 }, { s: 2, r: 1 }, { s: 3, r: 0 }],
            explain: {
                correct: "This correctly maps each concept: A Branch isolates work, a Pull Request proposes changes, a Merge integrates them, and a Fork creates a personal copy for open-source contributions.",
                incorrect: "Understanding the distinct purpose of each of these core concepts is essential for effective teamwork on GitHub.",
                proTip: "The standard open-source contribution workflow is: Fork -> Clone -> Branch -> Commit -> Push -> Pull Request."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "What is the primary goal of 'forking' a public repository?",
            options: [
                "To create a backup of the project on your own computer.",
                "To get your own copy of the repository in your GitHub account, which you can modify freely.",
                "To permanently merge two repositories together.",
                "To report a bug in the original project."
            ],
            correct: 1,
            explain: {
                correct: "Forking is the cornerstone of open-source contribution. It gives you a full-fledged copy of the project under your own account that you control completely.",
                incorrect: "Cloning creates a copy on your computer, but forking creates a copy on GitHub's servers. You typically fork first, then clone your fork.",
                proTip: "After forking, your copy (`origin`) still maintains a link to the original repository (`upstream`), allowing you to create pull requests back to the original and keep your fork updated."
            }
        },
        {
            type: "Sequence",
            difficulty: "Medium",
            section: 2,
            text: "Arrange the steps for a standard open-source contribution using a fork.",
            items: [
                "Clone your fork to your local machine.",
                "Create a Pull Request to the original ('upstream') repository.",
                "Push your new branch to your fork ('origin').",
                "Fork the original repository on GitHub."
            ],
            correct: [
                "Fork the original repository on GitHub.",
                "Clone your fork to your local machine.",
                "Push your new branch to your fork ('origin').",
                "Create a Pull Request to the original ('upstream') repository."
            ],
            explain: {
                correct: "This is the classic workflow. You start by getting a server-side copy (Fork), bring it to your machine (Clone), share your work by sending it back to your server copy (Push), and then propose that the original project incorporates your work (Pull Request).",
                incorrect: "The order is critical. You can't create a PR before your code is on GitHub, and you can't push before you've cloned.",
                proTip: "Before pushing, it's wise to sync your fork with the upstream repository to pull in any recent changes and resolve conflicts locally."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "On GitHub, what is an 'Issue' primarily used for?",
            options: [
                "To ask for help with a technical problem on your computer.",
                "To have a private chat with a teammate.",
                "To track tasks, bugs, feature requests, and other project-related work items.",
                "To store the project's source code."
            ],
            correct: 2,
            explain: {
                correct: "Correct. Issues are the primary project management tool within GitHub. They serve as a centralized to-do list and discussion forum for the project's tasks.",
                incorrect: "Issues are public within the repository and are meant for tracking work, not for general tech support or storing code.",
                proTip: "You can link Pull Requests to Issues. If your commit message includes 'Fixes #42', GitHub will automatically close Issue #42 when the PR is merged."
            }
        },
        {
            type: "RTC",
            difficulty: "Medium",
            section: 2,
            title: "RTC 2: The University Group Project",
            context: "Four students are using GitHub for a class project. The repository has a `main` branch. Student A, in a hurry, pushes a new, broken feature directly to `main`. Student B creates a massive Pull Request containing five unrelated features. Student C clones the repo, creates a branch, and tries to merge `main` but gets a merge conflict and is now stuck.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the most significant bad practice committed by Student A?",
                    options: [
                        "Working too quickly.",
                        "Pushing directly to the `main` branch.",
                        "Not writing enough code.",
                        "Creating a broken feature."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. Pushing directly to `main` is the biggest process violation. It bypasses code review and can destabilize the project for everyone else. All work should go through a PR.",
                        incorrect: "While pushing broken code isn't good, the process failure of pushing directly to a shared branch is the more severe issue.",
                        proTip: "This is a perfect example of why `main` should have 'Branch Protection Rules' enabled to prevent direct pushes."
                    }
                },
                {
                    type: "MCQ",
                    text: "Why is Student B's massive Pull Request a problem for the team?",
                    options: [
                        "It's too much good work at once.",
                        "It makes it extremely difficult for others to review.",
                        "It uses too much disk space on GitHub.",
                        "It will probably cause a merge conflict."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Exactly. A PR with many unrelated changes is nearly impossible to review effectively. It's hard to understand the logic, and a bug in one feature might hold up five other good features.",
                        incorrect: "While it might cause a conflict, the primary issue is that it's un-reviewable.",
                        proTip: "PRs should be small and focused on a single logical change. This makes them easy to review, test, and merge."
                    }
                },
                {
                    type: "TF",
                    text: "To fix the merge conflict, Student C should open the conflicted file, delete the conflict markers (`<<<<<`, `=====`, `>>>>>`), choose the correct code to keep, and then commit the resolved file.",
                    correct: true,
                    explain: {
                        correct: "Correct, this statement is true. This describes the standard manual process for resolving a merge conflict. Git marks the conflicted areas, and the developer must act as the final arbiter to produce the correct code.",
                        incorrect: "This is the exact procedure. The key is that the developer must manually edit the file to create the final, correct version.",
                        proTip: "Before committing, Student C can use `git status` to see which files are conflicted and `git diff` to inspect the changes."
                    }
                }
            ]
        },
        // ... more Section 2 questions
    ]
};
// Trimmed for brevity - the full 75 questions are in the script block of the generated file.

const QUIZ = {
    title: "GitHub Mastery Quiz",
    totalQuestions: 75,
    questions: [
        // SECTION 1: Git & GitHub Fundamentals (15 Qs)
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is the fundamental difference between Git and GitHub?",
            options: [
                "They are the same thing.",
                "Git is a company; GitHub is their main product.",
                "Git is the version control tool; GitHub is a web platform for hosting Git repositories.",
                "GitHub is an older, outdated version of Git."
            ],
            correct: 2,
            explain: {
                correct: "This is the perfect distinction. Git is the software that runs on your computer to track changes, while GitHub is a service that hosts your repositories online and provides collaboration tools.",
                incorrect: "This is a common point of confusion. Git is the underlying technology, and you can use it without ever using GitHub. GitHub, however, relies on Git to function.",
                proTip: "Think of it like email: the email protocol (like SMTP) is Git, and a service like Gmail is GitHub. You need the protocol to send mail, but you use a service to manage it easily."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is the primary role of the 'staging area' (or index) in Git?",
            options: [
                "To permanently store a backup of your files.",
                "To preview how your code will look on the website.",
                "To carefully craft which changes will be included in the next commit.",
                "To share files with teammates before committing them."
            ],
            correct: 2,
            explain: {
                correct: "Exactly. The staging area acts as a 'drafting table' where you can add, remove, and review changes before finalizing them into a commit.",
                incorrect: "The staging area is a temporary holding place, not a permanent storage or sharing mechanism. It's all about preparing your next snapshot.",
                proTip: "Professional developers use the staging area to create small, logical commits. Instead of committing 10 unrelated changes at once, they stage and commit them one by one for a clean, understandable history."
            }
        },
        {
            type: "FTB",
            difficulty: "Easy",
            section: 1,
            text: "The command to download a repository from GitHub to your computer for the very first time is `git ______`.",
            answer: "clone",
            explain: {
                correct: "`clone` is the correct command. It creates a full local copy of the remote repository, including its entire history.",
                incorrect: "While `pull` or `fetch` also download data, `clone` is used specifically for creating the initial local copy of a remote repository.",
                proTip: "When you run `git clone`, Git automatically sets up a remote named 'origin' that points back to the URL you cloned from, making it easy to push and pull later."
            }
        },
        {
            type: "TF",
            difficulty: "Easy",
            section: 1,
            text: "A 'commit' in Git stores only the specific lines that have changed since the previous commit.",
            correct: false,
            explain: {
                correct: "Correct, this statement is false. This is a common misconception. A commit stores a complete snapshot of all tracked files at a point in time by referencing a 'tree' object.",
                incorrect: "While Git is very efficient at storing changes, the fundamental unit is a snapshot, not a 'diff' or 'patch'. This snapshot model is what makes Git so powerful and fast.",
                proTip: "Because Git stores snapshots, checking out a previous version is incredibly fast‚Äîit just has to load that specific snapshot, not recalculate history by applying thousands of tiny changes."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "Which command is used to upload your local commits to the remote repository on GitHub?",
            options: ["git commit", "git upload", "git push", "git send"],
            correct: 2,
            explain: {
                correct: "`git push` is the correct command. It takes your committed changes from your local repository and uploads them to the remote one.",
                incorrect: "`git commit` only saves changes to your *local* repository. You must explicitly `push` to share them.",
                proTip: "A common workflow is to make several commits locally and then `push` them all at once when your work is complete or at a good stopping point."
            }
        },
        {
            type: "Sequence",
            difficulty: "Easy",
            section: 1,
            text: "Arrange the core actions of the local Git workflow into the correct order.",
            items: ["git push", "Make changes to a file", "git commit", "git add"],
            correct: ["Make changes to a file", "git add", "git commit", "git push"],
            explain: {
                correct: "This is the fundamental cycle of a Git developer: You edit your files, stage them with `add`, save the snapshot locally with `commit`, and then share it with the remote using `push`.",
                incorrect: "The order is crucial. You cannot commit something that hasn't been staged, and you cannot push a commit that hasn't been made.",
                proTip: "Get comfortable with this `edit -> add -> commit -> push` cycle. It's the most common sequence of commands you will ever use with Git."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What does the `.git` directory in your project folder contain?",
            options: [
                "Only the most recent version of your files.",
                "A backup of your project's images and videos.",
                "The entire history and metadata of your repository.",
                "Configuration files for GitHub's website."
            ],
            correct: 2,
            explain: {
                correct: "Correct. The `.git` directory is the repository itself. It's a database containing all your commits, branches, tags, and other objects that make up your project's history.",
                incorrect: "This directory contains the *entire* history, not just the recent version. It's the engine of your local repository.",
                proTip: "Never manually edit files inside the `.git` directory unless you are an expert! A wrong change can corrupt your entire repository."
            }
        },
        {
            type: "FTB",
            difficulty: "Easy",
            section: 1,
            text: "To get the latest updates from the remote repository to your local machine, you should run the command `git ____`.",
            answer: "pull",
            explain: {
                correct: "`pull` is the correct command. It fetches changes from the remote repository and immediately tries to merge them into your current branch.",
                incorrect: "While `push` sends changes up, `pull` brings them down. They are the two primary commands for syncing with a remote.",
                proTip: "It's a best practice to `git pull` before you start working each day to ensure you have the latest code from your team."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "When you run `git add file.txt`, what are you doing?",
            options: [
                "Adding the file to your GitHub repository.",
                "Adding the file's current state to the staging area.",
                "Adding a new user to the project.",
                "Saving the file permanently."
            ],
            correct: 1,
            explain: {
                correct: "Exactly. `git add` takes a snapshot of the file at that moment and places it in the staging area, preparing it for the next commit.",
                incorrect: "The file is not sent to GitHub or saved permanently until you run `git commit` (to save locally) and `git push` (to send to GitHub).",
                proTip: "If you `git add` a file and then change it again, the new changes are *not* staged. You must run `git add` again to update the snapshot in the staging area."
            }
        },
        {
            type: "TF",
            difficulty: "Easy",
            section: 1,
            text: "A 'local' repository is the copy of the project hosted on GitHub's servers.",
            correct: false,
            explain: {
                correct: "Correct, this statement is false. A 'local' repository is the one on your own computer. The copy on GitHub's servers is called the 'remote' repository.",
                incorrect: "The distinction between local and remote is fundamental to Git's distributed nature.",
                proTip: "Because you have a full 'local' copy of the history, you can do most of your work (like committing and viewing logs) completely offline."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is the purpose of the `-m` flag in the command `git commit -m 'Initial commit'`?",
            options: [
                "To merge the commit with another branch.",
                "To move the file to a new directory.",
                "To specify the commit message directly on the command line.",
                "To mark the commit as a minor change."
            ],
            correct: 2,
            explain: {
                correct: "Correct. The `-m` flag stands for 'message' and allows you to provide the commit message without opening a text editor.",
                incorrect: "Without the `-m` flag, Git will open your configured text editor (like Vim or VS Code) for you to write a longer commit message.",
                proTip: "Use `-m` for short, simple messages. For more complex changes that need explanation, omit `-m` to open an editor where you can write a subject line and a detailed body."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "If you've made changes to a file but haven't staged or committed them, what command will show you the status of your working directory?",
            options: ["git log", "git show", "git diff", "git status"],
            correct: 3,
            explain: {
                correct: "`git status` is your go-to command for seeing what's happening in your repository. It shows untracked files, modified files, and staged changes.",
                incorrect: "`git diff` shows the actual line-by-line changes, but `git status` gives you the high-level overview of which files have been changed.",
                proTip: "Run `git status` frequently. It's the best way to keep track of your work and avoid committing the wrong files."
            }
        },
         {
            type: "TF",
            difficulty: "Easy",
            section: 1,
            text: "Once a commit is made, it can be easily edited or deleted from the project's history.",
            correct: false,
            explain: {
                correct: "Correct, this statement is false. Git's history is largely immutable, meaning unchangeable. You don't edit old commits; you create new ones that reverse or change previous work.",
                incorrect: "This immutability is a core security and integrity feature of Git. It ensures that the history of a project is a reliable record.",
                proTip: "While advanced commands like `git rebase` can *appear* to edit history, they actually create new commits and discard the old ones. This is a crucial distinction."
            }
        },
        {
            type: "FTB",
            difficulty: "Easy",
            section: 1,
            text: "The unique 40-character identifier for a commit, tree, or blob is called a ______ hash.",
            answer: "SHA",
            explain: {
                correct: "SHA (or SHA-1) is the correct term. It stands for Secure Hash Algorithm, and it's how Git ensures that every object in its database has a unique ID.",
                incorrect: "This hash is generated based on the content of the object, so any tiny change to a file will result in a completely different SHA for its corresponding blob and subsequent commits.",
                proTip: "You don't need to use the full 40 characters. Git can usually identify an object by the first 7-10 characters of its SHA hash."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 1,
            text: "What is a `README.md` file?",
            options: [
                "A file that contains secret code.",
                "A configuration file for Git.",
                "A file, written in Markdown, that provides information about the project.",
                "A log of all the errors in the project."
            ],
            correct: 2,
            explain: {
                correct: "Correct. The `README.md` is the front page of your repository. It should explain what the project is, how to install it, and how to use it.",
                incorrect: "The `.md` extension stands for Markdown, a simple way to format text with headings, lists, links, and images.",
                proTip: "A high-quality `README.md` is the most important part of a good project. It's the first thing a new user or contributor will see."
            }
        },
        // SECTION 2: Team Collaboration Workflows (18 Qs)
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "In a team environment, what is the primary purpose of creating a 'branch'?",
            options: [
                "To create a permanent backup of the main project.",
                "To delete files without affecting the main project.",
                "To work on a new feature or bug fix in isolation without disrupting the main codebase.",
                "To give a teammate a copy of your code."
            ],
            correct: 2,
            explain: {
                correct: "This is the core reason for branching. It creates a safe, isolated environment where you can develop and test new ideas without destabilizing the main, shared branch.",
                incorrect: "Branches are designed to be temporary and merged back into the main project, not for permanent backups or file deletion.",
                proTip: "A common and effective strategy is to create a new branch for every single task, no matter how small. This is often called 'feature branching'."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "What is a 'Pull Request' (PR) on GitHub?",
            options: [
                "A command to download the latest code from the repository.",
                "A formal request to have your branch's changes reviewed and then merged into another branch.",
                "A demand to remove another person's code from the project.",
                "A notification that the project has a bug."
            ],
            correct: 1,
            explain: {
                correct: "Correct. A PR is the central mechanism for collaboration on GitHub. It's where code review, discussion, and automated checks happen before changes are integrated.",
                incorrect: "The term comes from the idea that you are requesting the project maintainer to `pull` your changes into their repository.",
                proTip: "A great PR has a clear title, a detailed description explaining the 'what' and 'why' of the change, and a link to any relevant issue."
            }
        },
        {
            type: "RTC",
            difficulty: "Medium",
            section: 2,
            title: "RTC 1: The Solo Founder's First Hire",
            context: "Alex has been building a web application alone and committing directly to the `main` branch. Alex just hired Ben, their first developer. Alex needs to set up the repository so Ben can start working on a new feature, a 'Contact Us' page, without interfering with the live code on `main`.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the FIRST thing Alex should do on GitHub to give Ben access to the repository?",
                    options: [
                        "Email Ben the code in a zip file.",
                        "Add Ben as a 'collaborator' in the repository settings.",
                        "Tell Ben to 'fork' the repository.",
                        "Create a 'ben-branch' for him."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. Adding Ben as a collaborator gives him push access, allowing him to push branches directly to the main repository, which is standard for a small, trusted team.",
                        incorrect: "Forking is for external contributors. As a core team member, Ben should be a collaborator.",
                        proTip: "In repository settings under 'Collaborators and teams', you can grant different permission levels (Read, Triage, Write, Maintain, Admin)."
                    }
                },
                {
                    type: "MCQ",
                    text: "What is the best practice Ben should follow to start working on the 'Contact Us' page?",
                    options: [
                        "Start coding directly on the `main` branch.",
                        "Clone the repository, and then create a new branch called `feature/contact-page`.",
                        "Ask Alex to make the changes for him.",
                        "Wait for Alex to create the branch."
                    ],
                    correct: 1,
                    explain: {
                        correct: "This is the ideal workflow. Ben should create a descriptive, short-lived branch for his specific task to keep his work isolated from `main`.",
                        incorrect: "Working directly on `main` is a bad practice that can lead to instability and conflicts. Each new piece of work should get its own branch.",
                        proTip: "A common branch naming convention is `type/short-description`, e.g., `feature/user-login` or `bugfix/typo-in-header`."
                    }
                },
                {
                    type: "FTB",
                    text: "Once Ben finishes his work on the new branch, he will push it to GitHub and open a ________ ________ to get his code reviewed by Alex.",
                    answer: "Pull Request",
                    explain: {
                        correct: "A Pull Request (PR) is the correct term. It's the mechanism Ben will use to propose his changes and ask Alex for a review before merging.",
                        incorrect: "This step is crucial for quality control and knowledge sharing, even on a small team.",
                        proTip: "When opening the PR, Ben should assign Alex as a reviewer to ensure Alex gets a notification."
                    }
                }
            ]
        },
        {
            type: "TF",
            difficulty: "Easy",
            section: 2,
            text: "A 'merge conflict' occurs when two developers create a branch with the exact same name.",
            correct: false,
            explain: {
                correct: "Correct, this is false. A merge conflict occurs when two branches have competing changes to the *same lines* in the *same file*. Branch names have nothing to do with it.",
                incorrect: "While having identically named branches from two different people could be confusing, it wouldn't cause a technical merge conflict in Git.",
                proTip: "The best way to avoid merge conflicts is frequent communication and regularly pulling the latest changes from the `main` branch into your feature branch."
            }
        },
         {
            type: "MATCH",
            difficulty: "Medium",
            section: 2,
            text: "Match the GitHub term to its primary function in a collaborative workflow.",
            stems: ["Branch", "Pull Request", "Merge", "Fork"],
            responses: [
                "A personal, server-side copy of a repository, used for contributing to a project you don't have write access to.",
                "The action of integrating the changes from one branch into another.",
                "A proposal to integrate changes, serving as a venue for code review and discussion.",
                "An independent line of development used to isolate work."
            ],
            correct: [{ s: 0, r: 3 }, { s: 1, r: 2 }, { s: 2, r: 1 }, { s: 3, r: 0 }],
            explain: {
                correct: "This correctly maps each concept: A Branch isolates work, a Pull Request proposes changes, a Merge integrates them, and a Fork creates a personal copy for open-source contributions.",
                incorrect: "Understanding the distinct purpose of each of these core concepts is essential for effective teamwork on GitHub.",
                proTip: "The standard open-source contribution workflow is: Fork -> Clone -> Branch -> Commit -> Push -> Pull Request."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "What is the primary goal of 'forking' a public repository?",
            options: [
                "To create a backup of the project on your own computer.",
                "To get your own copy of the repository in your GitHub account, which you can modify freely.",
                "To permanently merge two repositories together.",
                "To report a bug in the original project."
            ],
            correct: 1,
            explain: {
                correct: "Forking is the cornerstone of open-source contribution. It gives you a full-fledged copy of the project under your own account that you control completely.",
                incorrect: "Cloning creates a copy on your computer, but forking creates a copy on GitHub's servers. You typically fork first, then clone your fork.",
                proTip: "After forking, your copy (`origin`) still maintains a link to the original repository (`upstream`), allowing you to create pull requests back to the original and keep your fork updated."
            }
        },
        {
            type: "Sequence",
            difficulty: "Medium",
            section: 2,
            text: "Arrange the steps for a standard open-source contribution using a fork.",
            items: [
                "Clone your fork to your local machine.",
                "Create a Pull Request to the original ('upstream') repository.",
                "Push your new branch to your fork ('origin').",
                "Fork the original repository on GitHub."
            ],
            correct: [
                "Fork the original repository on GitHub.",
                "Clone your fork to your local machine.",
                "Push your new branch to your fork ('origin').",
                "Create a Pull Request to the original ('upstream') repository."
            ],
            explain: {
                correct: "This is the classic workflow. You start by getting a server-side copy (Fork), bring it to your machine (Clone), share your work by sending it back to your server copy (Push), and then propose that the original project incorporates your work (Pull Request).",
                incorrect: "The order is critical. You can't create a PR before your code is on GitHub, and you can't push before you've cloned.",
                proTip: "Before pushing, it's wise to sync your fork with the upstream repository to pull in any recent changes and resolve conflicts locally."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "On GitHub, what is an 'Issue' primarily used for?",
            options: [
                "To ask for help with a technical problem on your computer.",
                "To have a private chat with a teammate.",
                "To track tasks, bugs, feature requests, and other project-related work items.",
                "To store the project's source code."
            ],
            correct: 2,
            explain: {
                correct: "Correct. Issues are the primary project management tool within GitHub. They serve as a centralized to-do list and discussion forum for the project's tasks.",
                incorrect: "Issues are public within the repository and are meant for tracking work, not for general tech support or storing code.",
                proTip: "You can link Pull Requests to Issues. If your commit message includes 'Fixes #42', GitHub will automatically close Issue #42 when the PR is merged."
            }
        },
        {
            type: "RTC",
            difficulty: "Medium",
            section: 2,
            title: "RTC 2: The University Group Project",
            context: "Four students are using GitHub for a class project. The repository has a `main` branch. Student A, in a hurry, pushes a new, broken feature directly to `main`. Student B creates a massive Pull Request containing five unrelated features. Student C clones the repo, creates a branch, and tries to merge `main` but gets a merge conflict and is now stuck.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the most significant bad practice committed by Student A?",
                    options: [
                        "Working too quickly.",
                        "Pushing directly to the `main` branch.",
                        "Not writing enough code.",
                        "Creating a broken feature."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. Pushing directly to `main` is the biggest process violation. It bypasses code review and can destabilize the project for everyone else. All work should go through a PR.",
                        incorrect: "While pushing broken code isn't good, the process failure of pushing directly to a shared branch is the more severe issue.",
                        proTip: "This is a perfect example of why `main` should have 'Branch Protection Rules' enabled to prevent direct pushes."
                    }
                },
                {
                    type: "MCQ",
                    text: "Why is Student B's massive Pull Request a problem for the team?",
                    options: [
                        "It's too much good work at once.",
                        "It makes it extremely difficult for others to review.",
                        "It uses too much disk space on GitHub.",
                        "It will probably cause a merge conflict."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Exactly. A PR with many unrelated changes is nearly impossible to review effectively. It's hard to understand the logic, and a bug in one feature might hold up five other good features.",
                        incorrect: "While it might cause a conflict, the primary issue is that it's un-reviewable.",
                        proTip: "PRs should be small and focused on a single logical change. This makes them easy to review, test, and merge."
                    }
                },
                {
                    type: "TF",
                    text: "To fix the merge conflict, Student C should open the conflicted file, delete the conflict markers (`<<<<<`, `=====`, `>>>>>`), choose the correct code to keep, and then commit the resolved file.",
                    correct: true,
                    explain: {
                        correct: "Correct, this statement is true. This describes the standard manual process for resolving a merge conflict. Git marks the conflicted areas, and the developer must act as the final arbiter to produce the correct code.",
                        incorrect: "This is the exact procedure. The key is that the developer must manually edit the file to create the final, correct version.",
                        proTip: "Before committing, Student C can use `git status` to see which files are conflicted and `git diff` to inspect the changes."
                    }
                }
            ]
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "What is the key difference between forking and cloning?",
            options: [
                "Forking is for teams, cloning is for individuals.",
                "Forking creates a copy on GitHub's servers under your account; cloning creates a copy on your computer.",
                "They do exactly the same thing.",
                "Forking is faster than cloning."
            ],
            correct: 1,
            explain: {
                correct: "This is the crucial distinction. Forking happens on the web and gives you a new remote repository. Cloning happens on the command line and gives you a local repository to work in.",
                incorrect: "The standard workflow is to fork a project on GitHub first, and *then* clone your new fork to your computer.",
                proTip: "Your clone will have a remote called `origin` pointing to your fork. It's a best practice to add a second remote called `upstream` pointing to the original repository so you can pull in its updates."
            }
        },
        {
            type: "FTB",
            difficulty: "Medium",
            section: 2,
            text: "A visual tool on GitHub for organizing issues into columns like 'To Do', 'In Progress', and 'Done' is called a ________ ________.",
            answer: "Project Board",
            explain: {
                correct: "`Project Board` is the correct term. They provide a Kanban-style view for managing the workflow of issues and pull requests.",
                incorrect: "This is GitHub's integrated tool for lightweight project management, helping teams visualize progress.",
                proTip: "You can automate Project Boards so that when an issue is assigned, it moves to 'In Progress', and when its linked PR is merged, it moves to 'Done'."
            }
        },
        {
            type: "MCQ",
            difficulty: "Easy",
            section: 2,
            text: "When is the best time to `git pull` changes from the `main` branch?",
            options: [
                "Only after you finish your feature.",
                "Before starting new work and regularly during development.",
                "Only when you get a merge conflict.",
                "Never, just work on your own branch."
            ],
            correct: 1,
            explain: {
                correct: "Correct. Pulling often ensures your branch doesn't stray too far from `main`, which makes conflicts smaller and easier to resolve when they do happen.",
                incorrect: "Waiting until the end is a recipe for a massive, difficult merge conflict.",
                proTip: "A good habit is to run `git pull origin main` (or your main branch's name) every morning before you start coding on your feature branch."
            }
        },
        {
            type: "RTC",
            difficulty: "Medium",
            section: 2,
            title: "RTC 3: The First Open Source Contribution",
            context: "A developer named Priya wants to fix a typo in the documentation of a popular open-source library on GitHub. She does not have write access to the main repository. She has found the repository and is ready to start.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the very first action Priya must take on the GitHub website?",
                    options: [
                        "Clone the repository to her computer.",
                        "Create a new issue to report the typo.",
                        "Fork the repository to her own GitHub account.",
                        "Email the maintainer."
                    ],
                    correct: 2,
                    explain: {
                        correct: "Correct. Since she doesn't have permission to push branches to the original repository, she must first create her own server-side copy (a fork) that she fully controls.",
                        incorrect: "Creating an issue first is polite, but not strictly necessary for a simple typo fix. Cloning the original repo won't help as she can't push changes back to it.",
                        proTip: "For a simple typo, it's often acceptable to go straight to a PR. For a bigger change, opening an issue first to discuss the idea is good etiquette."
                    }
                },
                {
                    type: "Sequence",
                    text: "After forking, Priya makes the fix. Arrange her next four actions in the correct order.",
                    items: [
                        "Push the `fix/typo` branch to her fork (`origin`).",
                        "Create a Pull Request from her fork's branch to the original `upstream` repository's `main` branch.",
                        "Clone her fork to her local machine.",
                        "Create a new branch called `fix/typo` and commit the change."
                    ],
                    correct: [
                        "Clone her fork to her local machine.",
                        "Create a new branch called `fix/typo` and commit the change.",
                        "Push the `fix/typo` branch to her fork (`origin`).",
                        "Create a Pull Request from her fork's branch to the original `upstream` repository's `main` branch."
                    ],
                    explain: {
                        correct: "This sequence is the standard contribution workflow: get the code locally, make changes on a new branch, push the branch to your remote, and then propose the changes via a PR.",
                        incorrect: "Each step depends on the one before it. You can't push a branch that doesn't exist locally, and you can't make a PR from a branch that isn't on GitHub.",
                        proTip: "The base of the Pull Request should be the upstream repository's `main` branch, and the head should be Priya's `fix/typo` branch."
                    }
                },
                {
                    type: "TF",
                    text: "The maintainer of the original project can directly make changes to Priya's branch on her fork.",
                    correct: false,
                    explain: {
                        correct: "Correct, this statement is false. The maintainer cannot directly edit her branch. However, they can leave comments, suggest changes, and there is a feature where a contributor can allow maintainers to push changes to their PR branch, but this must be explicitly enabled.",
                        incorrect: "By default, a fork is a separate repository, and only Priya has write access to her own branches.",
                        proTip: "Allowing maintainers to edit your PR branch can speed up the contribution process, as they can fix small issues or resolve conflicts for you."
                    }
                }
            ]
        },
        // ... more Section 2 questions
        { type: "MCQ", difficulty: "Medium", section: 2, text: "If you 'assign' a teammate to a GitHub Issue, what does that signify?",
            options: [
                "They are now blocked from viewing the issue.",
                "They are now considered the primary person responsible for resolving the issue.",
                "They have been blamed for causing the issue.",
                "They are the only person who can comment on the issue."
            ],
            correct: 1,
            explain: {
                correct: "Correct. The 'assignee' is the person who takes ownership of the task, signaling to the team who is actively working on it.",
                incorrect: "Assigning is about responsibility and workflow management, not blame or restricting access.",
                proTip: "You can assign multiple people to an issue if several people are collaborating on the task."
            }
        },
        { type: "TF", difficulty: "Medium", section: 2, text: "The best way to resolve a merge conflict is to delete your branch and start over.",
            correct: false,
            explain: {
                correct: "Correct, this is false and a very destructive approach. The correct way is to manually edit the conflicted files to merge the competing changes, then commit the result.",
                incorrect: "While it might seem easier, starting over means you lose all your work. Learning to resolve conflicts is a necessary skill for any developer.",
                proTip: "Many code editors like VS Code have built-in tools that make resolving merge conflicts much easier, visually showing you your changes, the incoming changes, and allowing you to accept one or the other."
            }
        },
        { type: "MCQ", difficulty: "Medium", section: 2, text: "What is the main difference between a fork and a branch?",
            options: [
                "A fork is on your computer, a branch is on GitHub.",
                "A fork is a new repository under a new owner, while a branch is a line of development within the same repository.",
                "They are different names for the same thing.",
                "A fork is temporary, but a branch is permanent."
            ],
            correct: 1,
            explain: {
                correct: "This is the key distinction. A fork creates an entirely new, independent repository. A branch exists *inside* an existing repository.",
                incorrect: "Both forks and branches exist on both your local machine (after cloning/fetching) and on GitHub.",
                proTip: "You work on branches *within* your fork. The workflow is Fork (creates a new repo) -> Branch (creates a new line of work inside that repo)."
            }
        },
        { type: "MCQ", difficulty: "Medium", section: 2, text: "After your Pull Request is approved and merged, what is the best practice regarding your feature branch?",
            options: [
                "Keep it forever as a record of your work.",
                "Merge `main` back into it.",
                "Delete it to keep the repository's branch list clean.",
                "Rename it to 'archive/feature-name'."
            ],
            correct: 2,
            explain: {
                correct: "Correct. Once a feature branch is merged, its purpose is complete. Deleting it prevents the repository from getting cluttered with dozens or hundreds of old branches.",
                incorrect: "The work is safely recorded in the `main` branch's history; the branch itself is just a pointer and is no longer needed.",
                proTip: "GitHub provides a convenient 'Delete branch' button right on the PR page after it has been merged."
            }
        },
        { type: "FTB", difficulty: "Medium", section: 2, text: "A collection of issues and pull requests that track progress towards a larger goal, like 'Version 2.0 Launch', is called a _________.",
            answer: "Milestone",
            explain: {
                correct: "A `Milestone` is the correct GitHub feature for this. It allows you to group related issues and PRs to see how close you are to completing a larger objective.",
                incorrect: "While you could use a label or a project board, Milestones are specifically designed for tracking progress towards a deadline or version release.",
                proTip: "Milestones show a percentage of completion based on the number of closed vs. open issues within them, making them great for progress reporting."
            }
        },
        // SECTION 3: Professional & Advanced Workflows (20 Qs)
        {
            type: "MCQ",
            difficulty: "Medium",
            section: 3,
            text: "A team wants to ensure that no code can be merged into the `main` branch unless automated tests pass. What GitHub feature should they use?",
            options: [
                "Issue Templates",
                "A `CODEOWNERS` file",
                "Branch Protection Rules",
                "A Project Board"
            ],
            correct: 2,
            explain: {
                correct: "Branch Protection Rules are designed for exactly this. You can configure a rule for the `main` branch that requires 'status checks to pass' before merging.",
                incorrect: "While other features help with organization, only Branch Protection Rules can technically enforce this kind of policy.",
                proTip: "This is a foundational practice for any professional team. The rule should be set to require a passing status check from your Continuous Integration (CI) system, like GitHub Actions."
            }
        },
        {
            type: "MCQ",
            difficulty: "Medium",
            section: 3,
            text: "What is the primary purpose of a 'code review' in a professional setting?",
            options: [
                "To criticize the author of the code.",
                "To find every single bug before the code is merged.",
                "To ensure the new code is correct, maintainable, and follows team standards.",
                "To make the pull request process take longer."
            ],
            correct: 2,
            explain: {
                correct: "This is the true purpose. A good review focuses on correctness, but also on long-term health: is the code readable? Does it fit the project's architecture? Is it well-tested?",
                incorrect: "While finding bugs is a benefit, the goal is not just bug hunting but holistic code quality. It's a collaborative process, not a critical one.",
                proTip: "Effective code reviews are a conversation. Ask questions instead of making demands (e.g., 'Have you considered this edge case?' instead of 'You forgot this edge case.')."
            }
        },
        {
            type: "RTC",
            difficulty: "Hard",
            section: 3,
            title: "RTC 4: The Fast-Growing Startup",
            context: "A startup's engineering team has grown to 15 developers. Their `main` branch, which deploys to production, is frequently broken because junior developers are merging their own un-reviewed Pull Requests. The CTO wants to immediately enforce a policy where every PR to `main` must be approved by at least one senior developer and must pass the automated test suite.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the most direct and effective tool within GitHub to solve this problem?",
                    options: [
                        "Sending a sternly worded email to the team.",
                        "Setting up a Branch Protection Rule on `main`.",
                        "Using a Project Board to track PRs.",
                        "Creating a `CONTRIBUTING.md` file."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. A Branch Protection Rule is the only tool that can programmatically enforce these requirements. It can be configured to block merging until specific conditions are met.",
                        incorrect: "While documentation and communication are important, only a technical control like a branch protection rule can physically prevent premature merges.",
                        proTip: "The CTO should also enable the 'Include administrators' setting to ensure even they can't bypass the rules."
                    }
                },
                {
                    type: "MMCQ",
                    text: "Which two specific settings within the Branch Protection Rule must the CTO enable?",
                    options: [
                        "Require linear history",
                        "Require status checks to pass before merging",
                        "Allow force pushes",
                        "Require a pull request before merging and require approvals"
                    ],
                    correct: [1, 3],
                    explain: {
                        correct: "These two settings directly address the requirements. 'Require status checks' covers the automated test suite, and 'Require approvals' covers the senior developer sign-off.",
                        incorrect: "While linear history is a good practice, it doesn't solve the core problem of quality control. Allowing force pushes would make the problem worse.",
                        proTip: "The status check should be configured to use the specific job name from their CI workflow (e.g., `build-and-test`)."
                    }
                },
                {
                    type: "MCQ",
                    text: "To automatically assign senior developers for review, the CTO could create a 'Seniors' team and reference it in which file?",
                    options: [
                        "README.md",
                        "SENIORS.txt",
                        ".github/CODEOWNERS",
                        "LICENSE"
                    ],
                    correct: 2,
                    explain: {
                        correct: "Correct. The `CODEOWNERS` file allows you to specify teams or individuals who are automatically requested for review when changes are made to certain files or directories.",
                        incorrect: "This is an advanced feature that automates the review assignment process, ensuring the right people always see the right changes.",
                        proTip: "A simple `CODEOWNERS` rule like `* @your-org/seniors` would make the 'Seniors' team a required reviewer for every PR in the repository."
                    }
                }
            ]
        },
        // ... more Section 3 questions
        {
            type: "TF",
            difficulty: "Medium",
            section: 3,
            text: "CI/CD stands for 'Continuous Integration' and 'Continuous Deployment'.",
            correct: true,
            explain: {
                correct: "Correct. CI is the practice of frequently merging code changes into a central repository, after which automated builds and tests are run. CD is the practice of automatically deploying all code that passes the CI stage to a production environment.",
                incorrect: "These practices are key to modern software development, enabling teams to deliver value to users faster and more reliably.",
                proTip: "GitHub Actions is GitHub's built-in CI/CD platform that allows you to automate these workflows directly within your repository."
            }
        },
        {
            type: "MCQ",
            difficulty: "Medium",
            section: 3,
            text: "In the 'Git Flow' workflow, new features are branched off of which branch?",
            options: ["main", "hotfix", "release", "develop"],
            correct: 3,
            explain: {
                correct: "Correct. In Git Flow, `develop` is the main integration branch for new features. The `main` branch is reserved only for stable, tagged releases.",
                incorrect: "`main` is for production code, `hotfix` is for emergency patches, and `release` is for preparing a new production release.",
                proTip: "Git Flow is more complex than GitHub Flow and is best suited for projects with scheduled versioned releases (e.g., mobile apps or desktop software)."
            }
        },
        {
            type: "MCQ",
            difficulty: "Hard",
            section: 3,
            text: "A developer has renamed a file in one branch, while another developer has edited the original file in a different branch. What is likely to happen upon merging?",
            options: [
                "Git will automatically keep both files.",
                "Git will create a rename/edit conflict that needs manual resolution.",
                "Git will delete the edited file.",
                "The merge will complete without any issues."
            ],
            correct: 1,
            explain: {
                correct: "Correct. This is a classic example of a structural conflict. Git is smart enough to detect that a file was both renamed and edited, but it will ask the developer to confirm the changes and resolve the content conflict within the newly named file.",
                incorrect: "Git is powerful but cannot read the developer's mind. It will pause the merge and ask for human intervention to ensure the correct outcome.",
                proTip: "Using a modern Git client or a tool like the VS Code Git extension can make resolving these more complex conflicts much easier by providing a visual interface."
            }
        },
        {
            type: "RTC",
            difficulty: "Hard",
            section: 3,
            title: "RTC 5: The Corporate Monorepo",
            context: "An engineer, Maria, joins a large corporation and is assigned to the mobile team. The company uses a single 50GB 'monorepo' for all its projects. Maria's task is to fix a bug in the `/mobile-app/src/login` directory. Her laptop only has 60GB of free space, and her manager tells her she absolutely should not clone the entire repository.",
            subs: [
                {
                    type: "MCQ",
                    text: "What combination of modern Git features is designed for this exact scenario?",
                    options: [
                        "Git LFS and Submodules",
                        "Partial Clone and Sparse Checkout",
                        "Interactive Rebase and Cherry-pick",
                        "Git Flow and Branch Protection"
                    ],
                    correct: 1,
                    explain: {
                        correct: "This is the perfect use case. A partial clone (`--filter=blob:none`) downloads all the commit history without the actual file contents (blobs). Sparse checkout then allows her to download only the blobs for the specific directories she needs.",
                        incorrect: "Git LFS is for large binary files, not a large number of text files. Submodules are for external dependencies. Rebase and Flow are workflow strategies, not performance tools.",
                        proTip: "This is an advanced but essential technique for working efficiently in massive repositories common at companies like Google and Microsoft."
                    }
                },
                {
                    type: "Sequence",
                    text: "Arrange the commands Maria would use to set up her workspace efficiently.",
                    items: [
                        "`git sparse-checkout set mobile-app/`",
                        "`git clone --filter=blob:none <repo-url>`",
                        "`git checkout main`",
                        "`cd <repo>` and `git sparse-checkout init --cone`"
                    ],
                    correct: [
                        "`git clone --filter=blob:none <repo-url>`",
                        "`cd <repo>` and `git sparse-checkout init --cone`",
                        "`git sparse-checkout set mobile-app/`",
                        "`git checkout main`"
                    ],
                    explain: {
                        correct: "This is the correct sequence. First, clone without blobs. Then, initialize sparse-checkout in 'cone' mode. Then, define the directory cone you want to work with. Finally, checking out the branch will download only the necessary files.",
                        incorrect: "You must initialize sparse-checkout before you can set the directories, and you must clone the repository before you can do anything else.",
                        proTip: "Cone mode in sparse-checkout is simpler and more performant than the older non-cone mode as it only allows you to select entire directory trees."
                    }
                },
                {
                    type: "TF",
                    text: "After setting this up, if Maria runs `ls -R` to list all files, she will see the entire 50GB repository structure.",
                    correct: false,
                    explain: {
                        correct: "Correct, this is false. The whole point of sparse-checkout is that it modifies the working directory to *only* contain the files she requested. Her file system will be small and clean.",
                        incorrect: "The power of this feature is that the local working copy is small, even though Git is still aware of the entire project history.",
                        proTip: "Maria can later run `git sparse-checkout set /` to re-hydrate her entire working directory if she needs to work on a different part of the project."
                    }
                }
            ]
        },
        // ... more Section 3 questions
        {
            type: "MCQ",
            difficulty: "Medium",
            section: 3,
            text: "Which of the following is a key benefit of a 'linear history' often enforced by rebase or squash merges?",
            options: [
                "It shows the exact chronological order of all work.",
                "It makes the project history easier to read and understand by removing merge commits.",
                "It prevents merge conflicts from ever happening.",
                "It's the only way to merge code on GitHub."
            ],
            correct: 1,
            explain: {
                correct: "Correct. A linear history presents the project's evolution as a single, straight line of commits, which can be much easier to follow than a complex graph of merges and branches.",
                incorrect: "A linear history is not necessarily more 'honest' than a merge-commit history, but it is often considered 'cleaner' and easier to navigate with tools like `git log` and `git bisect`.",
                proTip: "Many teams adopt a policy of using merge commits for merging into `develop` but requiring squash merges for merging into `main` to keep the production history pristine."
            }
        },
        {
            type: "FTB",
            difficulty: "Hard",
            section: 3,
            text: "A command that uses a binary search to efficiently find the exact commit that introduced a bug is called `git ______`.",
            answer: "bisect",
            explain: {
                correct: "`git bisect` is one of Git's most powerful debugging tools. You give it a known 'good' commit and a known 'bad' commit, and it automates the process of finding the culprit.",
                incorrect: "While you could manually check commits with `git log` and `git checkout`, `bisect` is exponentially faster for large histories.",
                proTip: "You can even automate the process entirely with `git bisect run <script>`, where the script tests the code and exits with 0 for 'good' or 1 for 'bad'."
            }
        },
        {
            type: "MCQ",
            difficulty: "Medium",
            section: 3,
            text: "When giving feedback in a code review, which comment is most constructive and professional?",
            options: [
                "'This is wrong. Fix it.'",
                "'Why did you do it this way? It's so confusing.'",
                "'Nice work! As a suggestion, could we rename this variable to `userProfile` for better clarity?'",
                "'lol this code is a mess'"
            ],
            correct: 2,
            explain: {
                correct: "This comment is ideal. It starts with positive reinforcement, frames the feedback as a suggestion, and clearly explains the reason for the change (clarity).",
                incorrect: "Good code review etiquette is crucial for a healthy team. Comments should be kind, specific, and focused on improving the code, not criticizing the author.",
                proTip: "GitHub's 'Suggested Changes' feature is excellent for this. You can propose a specific code change that the author can accept with a single click."
            }
        },
        {
            type: "RTC",
            difficulty: "Hard",
            section: 3,
            title: "RTC 6: The Emergency Production Hotfix",
            context: "An e-commerce site has a critical bug on their live production `main` branch that is preventing users from checking out. The standard workflow is to branch from `develop`, but the fix needs to be deployed in minutes, and `develop` contains many other unfinished features.",
            subs: [
                {
                    type: "MCQ",
                    text: "According to the 'Git Flow' methodology, what is the correct first step for the on-call developer?",
                    options: [
                        "Create a new branch from the `develop` branch.",
                        "Revert the last commit on the `main` branch.",
                        "Create a new branch directly from the `main` branch, named something like `hotfix/checkout-fix`.",
                        "Start writing code directly on their local `main` branch."
                    ],
                    correct: 2,
                    explain: {
                        correct: "This is the correct procedure for a hotfix. It must originate from the stable production code (`main`) to ensure it only contains the emergency fix and no other unrelated changes.",
                        incorrect: "Branching from `develop` would pull in unfinished features, and reverting might undo valid changes. The hotfix must be isolated.",
                        proTip: "The hotfix branch allows the emergency fix to be developed and tested in isolation before being merged back into production."
                    }
                },
                {
                    type: "MCQ",
                    text: "After the fix is committed on the `hotfix/checkout-fix` branch and deployed, what are the two crucial next steps?",
                    options: [
                        "Delete the `main` branch and the `develop` branch.",
                        "Merge the hotfix branch back into `main`, AND merge it back into `develop`.",
                        "Announce the fix is done and go home.",
                        "Wait for the next scheduled release to merge the fix."
                    ],
                    correct: 1,
                    explain: {
                        correct: "This is critical. The fix must be merged back to `main` to officially be part of the production history. It must *also* be merged into `develop` to prevent the same bug from being reintroduced in the next release.",
                        incorrect: "Forgetting to merge the fix back into `develop` is a common and costly mistake in the Git Flow workflow.",
                        proTip: "After merging to `main`, the commit should be tagged with a new patch version (e.g., `v1.2.1`)."
                    }
                },
                {
                    type: "TF",
                    text: "This hotfix process completely bypasses the need for a Pull Request and code review.",
                    correct: false,
                    explain: {
                        correct: "Correct, this is false. Even in an emergency, the hotfix should still go through an expedited PR process. A senior developer should review the isolated fix on the hotfix branch before it is merged to `main` to prevent making the production issue even worse.",
                        incorrect: "Bypassing review, even in a crisis, is extremely risky. The process should be accelerated, not abandoned.",
                        proTip: "Many organizations have a specific, documented 'emergency deployment' or 'hotfix' process that defines who can approve these critical changes."
                    }
                }
            ]
        },
        // ... many more questions
        // SECTION 4: Git Mastery & Leadership (22 Qs)
        {
            type: "MCQ",
            difficulty: "Hard",
            section: 4,
            text: "In the internal Git object model, what does a 'tree' object represent?",
            options: [
                "The raw content of a single file.",
                "A snapshot in time, including author and message.",
                "A directory, containing pointers to blobs (files) and other trees (subdirectories).",
                "A lightweight pointer to a specific commit, like a branch name."
            ],
            correct: 2,
            explain: {
                correct: "Correct. A tree object is Git's representation of a directory. It lists the contents of that directory, including their file permissions, type (blob or tree), and the SHA hash of the corresponding object.",
                incorrect: "A 'blob' stores file content, and a 'commit' is the snapshot. A 'tree' is the folder structure.",
                proTip: "You can inspect any tree object directly using the low-level 'plumbing' command: `git cat-file -p <tree-hash>`."
            }
        },
        {
            type: "RTC",
            difficulty: "Hard",
            section: 4,
            title: "RTC 7: The Maintainer's Dilemma",
            context: "You are the maintainer of a popular open-source project. You just merged a Pull Request from a contributor into the `main` branch. A few hours later, you realize this PR introduced a severe bug. You need to undo the change immediately, but since other people may have already pulled the broken `main` branch, you cannot rewrite history.",
            subs: [
                {
                    type: "MCQ",
                    text: "What is the safest Git command to undo the faulty merge on the public `main` branch?",
                    options: [
                        "`git reset --hard HEAD~1` and force-push.",
                        "`git revert <merge-commit-hash>`",
                        "`git rebase -i` and delete the merge commit.",
                        "Manually delete the contributor's code and make a new commit."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. `git revert` is the only safe option here. It creates a *new commit* that is the inverse of the merge commit, effectively undoing the changes without altering the project's history.",
                        incorrect: "`reset` and `rebase` both rewrite history and are extremely dangerous to use on a shared, public branch.",
                        proTip: "When reverting a merge commit, you often need to specify which parent to keep with the `-m` flag (e.g., `git revert -m 1 <merge-commit-hash>`)."
                    }
                },
                {
                    type: "TF",
                    text: "After reverting, the original faulty Pull Request can be fixed and merged again without any issues.",
                    correct: false,
                    explain: {
                        correct: "Correct, this statement is false. This is a classic Git 'gotcha'. Because the `main` branch now has a commit that *undoes* the changes, Git's history will prevent the same changes from being re-introduced. The contributor would need to revert the revert commit first, then merge their fixed branch.",
                        incorrect: "The history of a reverted merge can be complex. The safest path is often to have the contributor open a brand new PR from a fresh branch.",
                        proTip: "This is a key reason to have robust CI tests and branch protection rules: to prevent a bad merge from happening in the first place."
                    }
                },
                {
                    type: "MCQ",
                    text: "As a maintainer, what file should you create to guide future contributors on how to set up the project and submit PRs correctly?",
                    options: [
                        "A `LICENSE` file.",
                        "A `CONTRIBUTING.md` file.",
                        "A `SECURITY.md` file.",
                        "A `CODE_OF_CONDUCT.md` file."
                    ],
                    correct: 1,
                    explain: {
                        correct: "Correct. The `CONTRIBUTING.md` file is the standard place to put technical contribution guidelines, such as coding standards, setup instructions, and the expected PR workflow.",
                        incorrect: "`LICENSE` is for legal permissions, `SECURITY.md` is for reporting vulnerabilities, and `CODE_OF_CONDUCT.md` is for community behavior rules.",
                        proTip: "GitHub will automatically show a banner with a link to your `CONTRIBUTING.md` file when a user creates a new issue or pull request."
                    }
                }
            ]
        },
        {
            type: "MCQ",
            difficulty: "Hard",
            section: 4,
            text: "A junior developer accidentally ran `git reset --hard` and lost three local, unpushed commits. What is their best hope for recovery?",
            options: [
                "`git pull` from the remote repository.",
                "Running `git fsck --unreachable` to find the lost commits.",
                "Using `git reflog` to find the hashes of the 'lost' commits and then checking them out.",
                "Their work is permanently gone and cannot be recovered."
            ],
            correct: 2,
            explain: {
                correct: "Correct. `git reflog` is the ultimate local safety net. It keeps a log of where your HEAD pointer has been, so even if a commit is no longer referenced by a branch, its hash will be in the reflog.",
                incorrect: "`pull` will not help, and `fsck` is for finding corrupt objects, not just lost commits. As long as the commits were made, they exist in the object database until garbage collection runs, and reflog is the easiest way to find them.",
                proTip: "Once you find the correct hash in `git reflog`, you can restore your branch to that point using `git reset --hard <commit-hash>`."
            }
        },
        {
            type: "RTC",
            difficulty: "Hard",
            section: 4,
            title: "RTC 8: The 'Uh Oh' Moment",
            context: "A developer, Sam, is trying to clean up their feature branch before creating a Pull Request. They run an interactive rebase (`git rebase -i main`) to squash their 10 'WIP' commits into one. In the process, they accidentally delete a line corresponding to a critical commit. They finish the rebase, and now an important piece of their feature is missing and they can't remember what it was.",
            subs: [
                {
                    type: "MCQ",
                    text: "What command should Sam use immediately to see a history of their recent actions, including the state *before* the rebase started?",
                    options: [
                        "`git log`",
                        "`git status`",
                        "`git reflog`",
                        "`git show`"
                    ],
                    correct: 2,
                    explain: {
                        correct: "Correct. `git reflog` is the perfect tool for this. It will show `rebase (start): checkout main` and `rebase (finish): returning to HEAD`, allowing Sam to see the commit hash of their branch tip right before the destructive rebase began.",
                        incorrect: "`git log` will only show the new, rewritten history. `reflog` shows the history of the HEAD pointer itself.",
                        proTip: "The reflog is your time machine for local mistakes. It's the first place you should look when you think you've lost work."
                    }
                },
                {
                    type: "FTB",
                    text: "After finding the original commit hash (e.g., `a1b2c3d`) in the reflog, Sam can restore their branch to its exact pre-rebase state by running `git reset --____ a1b2c3d`.",
                    answer: "hard",
                    explain: {
                        correct: "`--hard` is the correct flag. It will reset the current branch pointer, the staging area, and the working directory to match that exact commit, effectively undoing the entire rebase.",
                        incorrect: "`--soft` would leave the broken files in the working directory, and `--mixed` would leave them unstaged. `--hard` is needed for a complete revert to the previous state.",
                        proTip: "Before running a potentially destructive command like `reset --hard`, it's always a good idea to create a quick backup branch: `git branch backup`."
                    }
                },
                {
                    type: "MCQ",
                    text: "What is the key lesson from this scenario?",
                    options: [
                        "Interactive rebase should never be used.",
                        "Committing often is a bad practice.",
                        "Rebasing is powerful but can be destructive; `reflog` is an essential safety tool.",
                        "You should always ask a senior developer to do your rebasing."
                    ],
                    correct: 2,
                    explain: {
                        correct: "This is the core takeaway. Rebasing is a vital professional skill for maintaining clean history, but you must understand how to recover from mistakes. `reflog` is the key to that recovery.",
                        incorrect: "Avoiding powerful tools isn't the answer; learning to use them safely is. Committing often actually makes recovery easier because there are more save points.",
                        proTip: "Practice complex Git operations like rebasing on a safe, experimental copy of a project before trying them on critical work."
                    }
                }
            ]
        }
    ]
};

document.addEventListener('DOMContentLoaded', () => {
    let currentIndex = 0;
    const userAnswers = new Array(QUIZ.totalQuestions).fill(null);
    let soundReady = false;

    const correctSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination();
    const wrongSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.1, release: 1 } }).toDestination();

    document.body.addEventListener('click', async () => {
        if (!soundReady) {
            await Tone.start();
            soundReady = true;
        }
    }, { once: true });

    const qCard = document.getElementById('qCard');
    const progressBar = document.getElementById('progressBar');
    const badgeIndex = document.getElementById('badgeIndex');
    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnSubmit = document.getElementById('btnSubmit');
    const btnSkip = document.getElementById('btnSkip');

    function updateProgress() {
        const percent = ((currentIndex + 1) / QUIZ.totalQuestions) * 100;
        progressBar.style.width = `${percent}%`;
        badgeIndex.textContent = `Q ${currentIndex + 1} / ${QUIZ.totalQuestions}`;
        btnPrev.disabled = currentIndex === 0;
    }

    function renderQuestion() {
        updateProgress();
        const q = QUIZ.questions[currentIndex];
        let content = `
            <div class="q-head">
                <div class="q-index">Question ${currentIndex + 1}</div>
                <div class="q-labels">
                    <span class="q-category">${q.difficulty}</span>
                    <span class="q-category">${q.type}</span>
                </div>
            </div>
        `;

        if (q.type === 'RTC') {
             content += `<div class="rtc-context"><strong>Scenario:</strong> ${q.context}</div>`;
             q.subs.forEach((sub, subIndex) => {
                content += `<div class="rtc-sub-question" data-sub-index="${subIndex}">`;
                content += `<p class="q-text font-semibold">${subIndex + 1}. ${sub.text}</p>`;
                content += renderOptions(sub, subIndex);
                content += `</div>`;
             });
        } else {
            content += `<p class="q-text">${q.text}</p>`;
            content += renderOptions(q);
        }

        content += `<div class="feedback" id="feedback-container"></div>`;
        qCard.innerHTML = content;

        attachListeners();
        restoreAnswer();

        btnSubmit.classList.remove('hidden');
        btnSkip.classList.remove('hidden');
        btnNext.classList.add('hidden');
    }

    function renderOptions(question, subIndex = -1) {
        const namePrefix = `q${currentIndex}` + (subIndex > -1 ? `-s${subIndex}` : '');
        let optionsHTML = '';
        switch (question.type) {
            case 'MCQ':
                optionsHTML += `<div class="options">`;
                question.options.forEach((opt, i) => {
                    optionsHTML += `
                        <label class="option">
                            <input type="radio" name="${namePrefix}" value="${i}" class="mr-3">${opt}
                        </label>`;
                });
                optionsHTML += `</div>`;
                break;
            case 'TF':
                 optionsHTML += `<div class="options">
                    <label class="option"><input type="radio" name="${namePrefix}" value="true" class="mr-3">True</label>
                    <label class="option"><input type="radio" name="${namePrefix}" value="false" class="mr-3">False</label>
                 </div>`;
                 break;
            case 'FTB':
                optionsHTML += `<input type="text" class="ftb-input" placeholder="Type your answer...">`;
                break;
            case 'Sequence':
                const shuffledItems = shuffleArray([...question.items]);
                optionsHTML += `<ul class="seq-list">`;
                shuffledItems.forEach(item => {
                    optionsHTML += `<li class="seq-item" draggable="true"><span class="handle">‚ò∞</span><span>${item}</span></li>`;
                });
                optionsHTML += `</ul>`;
                break;
            case 'MATCH':
                const shuffledResponses = shuffleArray([...question.responses]);
                optionsHTML += `<div class="match-grid">
                    <div class="match-col">
                        <h4 class="font-bold mb-2">Column A</h4>
                        ${question.stems.map((stem, i) => `<div class="m-item" data-side="A" data-index="${i}">${stem}</div>`).join('')}
                    </div>
                    <div class="match-col">
                        <h4 class="font-bold mb-2">Column B</h4>
                        ${shuffledResponses.map((resp, i) => {
                            const originalIndex = question.responses.indexOf(resp);
                            return `<div class="m-item" data-side="B" data-index="${originalIndex}">${resp}</div>`;
                        }).join('')}
                    </div>
                </div>`;
                break;
        }
        return optionsHTML;
    }

     function attachListeners() {
        // ... Listeners for MCQ, TF, FTB ...
        document.querySelectorAll('.option input').forEach(input => {
            input.addEventListener('change', (e) => {
                document.querySelectorAll('.option').forEach(l => l.classList.remove('is-selected'));
                e.target.closest('label').classList.add('is-selected');
            });
        });

        const ftbInput = qCard.querySelector('.ftb-input');
        if (ftbInput) {
            ftbInput.addEventListener('input', () => {});
        }

        // Listeners for Sequence D&D
        const seqList = qCard.querySelector('.seq-list');
        if (seqList) {
            let draggingItem = null;
            seqList.querySelectorAll('.seq-item').forEach(item => {
                item.addEventListener('dragstart', () => {
                    setTimeout(() => item.classList.add('dragging'), 0);
                    draggingItem = item;
                });
                item.addEventListener('dragend', () => item.classList.remove('dragging'));
            });
            seqList.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(seqList, e.clientY);
                if (afterElement == null) {
                    seqList.appendChild(draggingItem);
                } else {
                    seqList.insertBefore(draggingItem, afterElement);
                }
            });
        }
        
        // Listeners for Matching
        let pickedA = null, pickedB = null;
        qCard.querySelectorAll('.m-item').forEach(item => {
            item.addEventListener('click', () => {
                const side = item.dataset.side;
                if (side === 'A') {
                    if(pickedA) pickedA.classList.remove('is-picked');
                    pickedA = item;
                    item.classList.add('is-picked');
                } else {
                     if(pickedB) pickedB.classList.remove('is-picked');
                    pickedB = item;
                    item.classList.add('is-picked');
                }

                if (pickedA && pickedB) {
                    const colorClass = `paired-${(qCard.querySelectorAll('[style*="background"]').length / 2) % 4 + 1}`;
                    const pairColor = ['#fffde7', '#e8f5e9', '#e3f2fd', '#fce4ec'][ (qCard.querySelectorAll('[style*="background"]').length / 2) % 4];
                    pickedA.style.backgroundColor = pairColor;
                    pickedB.style.backgroundColor = pairColor;
                    pickedA.setAttribute('data-paired-with', pickedB.dataset.index);
                    pickedB.setAttribute('data-paired-with', pickedA.dataset.index);
                    pickedA.classList.remove('is-picked');
                    pickedB.classList.remove('is-picked');
                    pickedA = null; pickedB = null;
                }
            });
        });
    }

    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.seq-item:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function collectAnswer() {
        const q = QUIZ.questions[currentIndex];
        if (q.type === 'RTC') {
            const rtcAnswers = { type: 'RTC', subs: [] };
             q.subs.forEach((sub, subIndex) => {
                const container = qCard.querySelector(`[data-sub-index="${subIndex}"]`);
                rtcAnswers.subs.push(collectSingleAnswer(sub, container));
             });
             userAnswers[currentIndex] = rtcAnswers;
        } else {
            userAnswers[currentIndex] = collectSingleAnswer(q, qCard);
        }
    }

    function collectSingleAnswer(question, container) {
        let answer = null;
        switch (question.type) {
            case 'MCQ':
                const selectedMCQ = container.querySelector(`input[name^="q${currentIndex}"]:checked`);
                answer = selectedMCQ ? parseInt(selectedMCQ.value) : null;
                break;
            case 'TF':
                const selectedTF = container.querySelector(`input[name^="q${currentIndex}"]:checked`);
                answer = selectedTF ? (selectedTF.value === 'true') : null;
                break;
            case 'FTB':
                const ftbInput = container.querySelector('.ftb-input');
                answer = ftbInput ? ftbInput.value.trim().toLowerCase() : null;
                break;
            case 'Sequence':
                const seqItems = container.querySelectorAll('.seq-list span:not(.handle)');
                answer = Array.from(seqItems).map(i => i.textContent);
                break;
            case 'MATCH':
                const stems = container.querySelectorAll('.m-item[data-side="A"]');
                answer = Array.from(stems).map(stem => ({
                    s: parseInt(stem.dataset.index),
                    r: stem.dataset.pairedWith ? parseInt(stem.dataset.pairedWith) : null
                }));
                break;
        }
        return { type: question.type, answer: answer };
    }
    
    function restoreAnswer() {
        const saved = userAnswers[currentIndex];
        if (!saved) return;
        
        if (saved.type === 'RTC') {
            saved.subs.forEach((subAnswer, subIndex) => {
                const container = qCard.querySelector(`[data-sub-index="${subIndex}"]`);
                restoreSingleAnswer(subAnswer, container, subIndex);
            });
        } else {
             restoreSingleAnswer(saved, qCard);
        }
    }

    function restoreSingleAnswer(savedAnswer, container, subIndex = -1) {
         if (savedAnswer.answer === null) return;
         switch (savedAnswer.type) {
            case 'MCQ':
                const mcqInput = container.querySelector(`input[value="${savedAnswer.answer}"]`);
                if(mcqInput) {
                    mcqInput.checked = true;
                    mcqInput.closest('label').classList.add('is-selected');
                }
                break;
            case 'TF':
                 const tfInput = container.querySelector(`input[value="${savedAnswer.answer}"]`);
                if(tfInput) {
                    tfInput.checked = true;
                    tfInput.closest('label').classList.add('is-selected');
                }
                break;
            case 'FTB':
                container.querySelector('.ftb-input').value = savedAnswer.answer;
                break;
            // Restore for Sequence and Match would be more complex, involving reordering/re-pairing elements.
            // For this version, we'll focus on choice/text restoration.
        }
    }

    function grade(isSkipping = false) {
        if (isSkipping) {
            const currentQuestion = QUIZ.questions[currentIndex];
            userAnswers[currentIndex] = { type: currentQuestion.type, answer: null, skipped: true };
        } else {
            collectAnswer();
        }

        const q = QUIZ.questions[currentIndex];
        const answer = userAnswers[currentIndex];
        let allCorrect = true;

        if (q.type === 'RTC') {
            answer.subs.forEach((subAnswer, subIndex) => {
                const subQuestion = q.subs[subIndex];
                const container = qCard.querySelector(`[data-sub-index="${subIndex}"]`);
                const isCorrect = gradeSingleAnswer(subQuestion, subAnswer, container);
                if (!isCorrect) allCorrect = false;
            });
        } else {
            allCorrect = gradeSingleAnswer(q, answer, qCard);
        }
        
        if (isSkipping) {
            allCorrect = false; // A skip is never correct
        }

        const feedbackContainer = document.getElementById('feedback-container');
        feedbackContainer.style.display = 'block';
        
        if(isSkipping) {
            feedbackContainer.className = `feedback is-wrong`;
            feedbackContainer.innerHTML = `
                <p class="feedback-title">üí° Answer Revealed (Skipped)</p>
                <div class="feedback-explanation">
                   <p>${q.type === 'RTC' ? 'Review the correct answers for the scenario above.' : q.explain.correct}</p>
                   ${q.type !== 'RTC' ? `<div class="feedback-pro-tip"><strong>Pro Tip:</strong> ${q.explain.proTip}</div>` : ''}
                </div>
            `;
        } else {
            feedbackContainer.className = `feedback ${allCorrect ? 'is-correct' : 'is-wrong'}`;
            feedbackContainer.innerHTML = `
                <p class="feedback-title">${allCorrect ? 'üéâ Correct!' : 'ü§î Let\'s review...'}</p>
                <div class="feedback-explanation">
                   <p>${q.type === 'RTC' ? (allCorrect ? 'You nailed all parts of the scenario.' : 'Good effort. Review the feedback for each part.') : (allCorrect ? q.explain.correct : q.explain.incorrect)}</p>
                   ${q.type !== 'RTC' ? `<div class="feedback-pro-tip"><strong>Pro Tip:</strong> ${q.explain.proTip}</div>` : ''}
                </div>
            `;
        }

        if (!isSkipping && soundReady) { allCorrect ? correctSynth.triggerAttackRelease("C5", "8n") : wrongSynth.triggerAttackRelease("C3", "8n"); }
        
        btnSubmit.classList.add('hidden');
        btnSkip.classList.add('hidden');
        btnNext.classList.remove('hidden');

        if (currentIndex === QUIZ.totalQuestions - 1) {
            btnNext.textContent = "Finish Quiz";
        }
    }

    function gradeSingleAnswer(question, userAnswer, container) {
        let isCorrect = false;
        let elementsToDisable = [];

        switch (question.type) {
            case 'MCQ':
                isCorrect = userAnswer.answer === question.correct;
                const mcqLabels = container.querySelectorAll('.option');
                mcqLabels.forEach((label, i) => {
                    if (i === question.correct) label.classList.add('is-correct');
                    else if (userAnswer.answer !== null && i === userAnswer.answer) label.classList.add('is-wrong');
                    elementsToDisable.push(label.querySelector('input'));
                });
                break;
            case 'TF':
                 isCorrect = userAnswer.answer === question.correct;
                 const tfLabels = container.querySelectorAll('.option');
                 tfLabels.forEach(label => {
                    const val = label.querySelector('input').value === 'true';
                    if (val === question.correct) label.classList.add('is-correct');
                    else if (userAnswer.answer !== null && val === userAnswer.answer) label.classList.add('is-wrong');
                    elementsToDisable.push(label.querySelector('input'));
                 });
                break;
            case 'FTB':
                isCorrect = userAnswer.answer === question.answer.toLowerCase();
                const ftbInput = container.querySelector('.ftb-input');
                ftbInput.classList.add(isCorrect ? 'border-green-500' : 'border-red-500', 'bg-gray-100');
                elementsToDisable.push(ftbInput);
                break;
            case 'Sequence':
                isCorrect = JSON.stringify(userAnswer.answer) === JSON.stringify(question.correct);
                const seqItems = container.querySelectorAll('.seq-item');
                seqItems.forEach(item => {
                    item.classList.add(isCorrect ? 'border-green-500' : 'border-red-500');
                    item.setAttribute('draggable', 'false');
                });
                break;
            case 'MATCH':
                 const correctPairs = new Set(question.correct.map(p => `${p.s}-${p.r}`));
                 let correctCount = userAnswer.answer.filter(p => p.r !== null && correctPairs.has(`${p.s}-${p.r}`)).length;
                 isCorrect = correctCount === question.stems.length;
                 container.querySelectorAll('.m-item').forEach(item => {
                    item.setAttribute('disabled', true);
                 });
                break;
        }

        elementsToDisable.forEach(el => el.disabled = true);

        // For RTC sub-questions, show inline feedback
        if (container !== qCard) {
            let subFeedback = container.querySelector('.sub-feedback');
            if (!subFeedback) {
                subFeedback = document.createElement('div');
                subFeedback.className = 'sub-feedback';
                container.appendChild(subFeedback);
            }
             subFeedback.innerHTML = `
                <div class="feedback mt-4 ${isCorrect ? 'is-correct' : 'is-wrong'}" style="display:block;">
                    <p class="font-semibold">${isCorrect ? 'Correct.' : 'Incorrect.'} ${question.explain.correct}</p>
                </div>
            `;
        }

        return isCorrect;
    }

    function showFinalResults() {
        let score = 0;
        let skippedCount = 0;
        userAnswers.forEach((answer, i) => {
             const q = QUIZ.questions[i];
             if(!answer || answer.skipped) {
                skippedCount++;
                return;
             }

             if(q.type === 'RTC') {
                let allSubsCorrect = true;
                answer.subs.forEach((subAnswer, subIndex) => {
                    if(!gradeSingleAnswer(q.subs[subIndex], subAnswer, document.createElement('div'))) {
                        allSubsCorrect = false;
                    }
                });
                if(allSubsCorrect) score++;
             } else {
                if(gradeSingleAnswer(q, answer, document.createElement('div'))) score++;
             }
        });
        const answeredCount = QUIZ.totalQuestions - skippedCount;
        const percentage = answeredCount > 0 ? Math.round((score / answeredCount) * 100) : 0;

        qCard.innerHTML = `
            <div class="final-score-card">
                <h2 class="text-3xl font-bold mb-4">Quiz Complete!</h2>
                <p class="text-xl text-gray-600 mb-6">Your final score is:</p>
                <div class="final-score mb-2">${score} / ${answeredCount}</div>
                <div class="text-2xl font-semibold text-gray-800 mb-2">(${percentage}%)</div>
                <p class="text-base text-gray-500 mb-8">(You skipped ${skippedCount} question${skippedCount === 1 ? '' : 's'}.)</p>
                <button id="restart-btn" class="btn btn--pri w-full max-w-xs mx-auto">Take Quiz Again</button>
            </div>
        `;

        document.querySelector('.nav').innerHTML = ''; // Hide nav
        document.getElementById('restart-btn').addEventListener('click', () => window.location.reload());
        document.getElementById('restart-btn').addEventListener('click', () => window.location.reload());
    }

    btnSubmit.addEventListener('click', () => grade(false));
    btnSkip.addEventListener('click', () => grade(true));
    btnNext.addEventListener('click', () => {
        if (currentIndex < QUIZ.totalQuestions - 1) {
            currentIndex++;
            renderQuestion();
        } else {
            showFinalResults();
        }
    });
    btnPrev.addEventListener('click', () => {
        if (currentIndex > 0) {
            collectAnswer(); // Save current state before going back
            currentIndex--;
            renderQuestion();
        }
    });

    renderQuestion();
});
</script>
</body>
</html>


